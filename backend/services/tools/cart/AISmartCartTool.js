const { StructuredTool } = require("@langchain/core/tools");
const { z } = require("zod");
const { ChatGoogleGenerativeAI } = require("@langchain/google-genai");
const mongoose = require("mongoose");
const Cart = require("../../../models/cartModel");
const Product = require("../../../models/productModel");
const VectorStoreManager = require("../../chatbot/VectorStoreManager");
const { llmConfig } = require("../../config/llmConfig");

/**
 * AISmartCartTool - AI-driven intelligent cart management tool
 * Replaces CartTool, ProductSelectionHelper, and QuantityExtractor
 * Uses Gemini-2.0-flash for natural language understanding and decision making
 */
class AISmartCartTool extends StructuredTool {
  constructor(userContext = null) {
    super();
    this.name = "ai_smart_cart";
    this.description = this.getOptimizedDescription();
    this.userContext = userContext;
    this.llm = new ChatGoogleGenerativeAI(llmConfig);
    this.debugMode = process.env.CHATBOT_DEBUG === "true";
    
    this.schema = z.object({
      query: z.string().describe("User's natural language query about cart operations, product adding, or shopping requests"),
    });
  }

  getOptimizedDescription() {
    return `ü§ñ AI SMART CART TOOL - Intelligent cart management using Gemini-2.0-flash for natural language understanding.

üõí **WHEN TO USE:**
- User wants to add products to cart: "mua", "th√™m v√†o gi·ªè", "add to cart"
- Shopping with quantities: "mua 3 c√°i", "l·∫•y v√†i s·∫£n ph·∫©m" 
- Product search + add: "t√¨m v√† mua", "search and buy"
- Selection criteria: "ch·ªçn r·∫ª nh·∫•t", "l·∫•y t·ªët nh·∫•t", "pick the best"
- Cart operations: view cart, remove items, clear cart
- Shopping with context: "mua cho team", "setup gaming"

üîç **AI CAPABILITIES:**
- Natural language intent detection
- Smart product search and selection
- Quantity extraction from text
- Price/quality preference understanding
- Context-aware recommendations
- Multilingual support (Vietnamese/English)

‚ö° **KEYWORDS:** mua, th√™m, cart, gi·ªè h√†ng, buy, add, purchase, t√¨m ki·∫øm, search, ch·ªçn, select

Only works when user is authenticated (userId available).`;
  }

  log(message, ...args) {
    if (this.debugMode) {
      console.log(`[AISmartCartTool] ${message}`, ...args);
    }
  }

  async _call({ query }) {
    try {
      // Get userId from context
      const userId = this.userContext ? this.userContext.getUserId() : null;

      if (!userId) {
        return "üîí ƒê·ªÉ s·ª≠ d·ª•ng gi·ªè h√†ng, b·∫°n c·∫ßn ƒëƒÉng nh·∫≠p v√†o t√†i kho·∫£n.";
      }

      this.log(`Processing cart query: "${query}" for userId: ${userId}`);

      // Get current cart for context
      const currentCart = await this.getCurrentCart(userId);
      
      // Get available products for AI analysis (sample to prevent token overflow)
      const availableProducts = await this.getAvailableProducts();

      // Create comprehensive AI prompt for cart analysis
      const aiPrompt = this.createCartAIPrompt(query, currentCart, availableProducts);

      this.log("Sending query to Gemini AI for cart analysis...");
      const aiResponse = await this.llm.invoke(aiPrompt);
      
      let aiResult;
      try {
        // Extract JSON from AI response
        const jsonMatch = aiResponse.content.match(/\{[\s\S]*\}/);
        if (!jsonMatch) {
          throw new Error("No JSON found in AI response");
        }
        aiResult = JSON.parse(jsonMatch[0]);
      } catch (parseError) {
        this.log("AI JSON parsing error:", parseError);
        return this.fallbackResponse(query, currentCart);
      }

      // Validate AI result
      if (!aiResult || typeof aiResult !== 'object') {
        this.log("Invalid AI result structure");
        return this.fallbackResponse(query, currentCart);
      }

      // Execute the AI-determined action
      return await this.executeAIAction(aiResult, userId);

    } catch (error) {
      this.log("Error in AISmartCartTool:", error);
      return `‚ùå L·ªói x·ª≠ l√Ω gi·ªè h√†ng: ${error.message}

üí° **G·ª£i √Ω:**
- Ki·ªÉm tra k·∫øt n·ªëi m·∫°ng
- Th·ª≠ l·∫°i v·ªõi c√¢u h·ªèi ƒë∆°n gi·∫£n h∆°n
- Li√™n h·ªá h·ªó tr·ª£ n·∫øu l·ªói ti·∫øp t·ª•c`;
    }
  }

  async getCurrentCart(userId) {
    try {
      const cart = await Cart.findOne({ user: userId }).populate('items.product');
      return {
        exists: !!cart,
        itemCount: cart ? cart.items.length : 0,
        totalPrice: cart ? cart.totalPrice : 0,
        items: cart ? cart.items.map(item => ({
          id: item.product._id.toString(),
          name: item.name,
          price: item.price,
          quantity: item.quantity,
          stock: item.product.stock
        })) : []
      };
    } catch (error) {
      this.log("Error getting current cart:", error);
      return { exists: false, itemCount: 0, totalPrice: 0, items: [] };
    }
  }

  async getAvailableProducts() {
    try {
      const products = await Product.find({ stock: { $gt: 0 } })
        .populate("category", "name")
        .sort({ averageRating: -1 })
        .limit(30) // Limit to prevent token overflow
        .lean();

      return products.map(product => ({
        id: product._id.toString(),
        name: product.name,
        brand: product.brand || "N/A",
        category: product.category?.name || "N/A",
        price: product.price,
        discountPrice: product.discountPrice || null,
        effectivePrice: product.discountPrice || product.price,
        stock: product.stock,
        rating: product.averageRating || 0,
        reviews: product.numReviews || 0,
        features: product.features || [],
        description: product.description || ""
      }));
    } catch (error) {
      this.log("Error getting available products:", error);
      return [];
    }
  }

  createCartAIPrompt(query, currentCart, availableProducts) {
    return `B·∫°n l√† AI chuy√™n gia qu·∫£n l√Ω gi·ªè h√†ng th√¥ng minh cho gaming gear shop. Ph√¢n t√≠ch y√™u c·∫ßu c·ªßa kh√°ch h√†ng v√† th·ª±c hi·ªán h√†nh ƒë·ªông ph√π h·ª£p.

**TH√îNG TIN GI·ªé H√ÄNG HI·ªÜN T·∫†I:**
${JSON.stringify(currentCart, null, 2)}

**S·∫¢N PH·∫®M C√ì S·∫¥N (m·∫´u):**
${JSON.stringify(availableProducts.slice(0, 20), null, 2)}

**Y√äU C·∫¶U KH√ÅCH H√ÄNG:** "${query}"

**NHI·ªÜM V·ª§:**
1. Ph√¢n t√≠ch √Ω ƒë·ªãnh th·ª±c s·ª± c·ªßa kh√°ch h√†ng v·ªÅ gi·ªè h√†ng
2. X√°c ƒë·ªãnh h√†nh ƒë·ªông c·∫ßn th·ª±c hi·ªán
3. Extract th√¥ng tin c·∫ßn thi·∫øt (s·∫£n ph·∫©m, s·ªë l∆∞·ª£ng, ti√™u ch√≠)
4. ƒê∆∞a ra quy·∫øt ƒë·ªãnh th√¥ng minh v√† ph·∫£n h·ªìi ph√π h·ª£p

**C√ÅC LO·∫†I H√ÄNH ƒê·ªòNG:**
- **add_product**: Th√™m s·∫£n ph·∫©m v√†o gi·ªè h√†ng
- **view_cart**: Xem gi·ªè h√†ng hi·ªán t·∫°i
- **remove_product**: X√≥a s·∫£n ph·∫©m kh·ªèi gi·ªè h√†ng  
- **clear_cart**: X√≥a to√†n b·ªô gi·ªè h√†ng
- **search_and_add**: T√¨m ki·∫øm v√† th√™m s·∫£n ph·∫©m
- **update_quantity**: C·∫≠p nh·∫≠t s·ªë l∆∞·ª£ng s·∫£n ph·∫©m

**QUY T·∫ÆC QUAN TR·ªåNG:**
- S·ª≠ d·ª•ng gi√° khuy·∫øn m√£i (discountPrice) n·∫øu c√≥
- Ki·ªÉm tra t·ªìn kho tr∆∞·ªõc khi th√™m
- Hi·ªÉu ƒë∆∞·ª£c s·ªë l∆∞·ª£ng t·ª´ ng√¥n ng·ªØ t·ª± nhi√™n
- √Åp d·ª•ng ti√™u ch√≠ l·ª±a ch·ªçn th√¥ng minh
- Extract product intent t·ª´ search results n·∫øu c·∫ßn
- ƒê∆∞a ra g·ª£i √Ω khi kh√¥ng ch·∫Øc ch·∫Øn

**PRODUCT SELECTION LOGIC:**
- "r·∫ª nh·∫•t" ‚Üí ch·ªçn s·∫£n ph·∫©m gi√° th·∫•p nh·∫•t
- "t·ªët nh·∫•t" ‚Üí ch·ªçn s·∫£n ph·∫©m rating cao nh·∫•t
- "ƒë·∫ßu ti√™n" ‚Üí ch·ªçn s·∫£n ph·∫©m ƒë·∫ßu ti√™n
- Th∆∞∆°ng hi·ªáu c·ª• th·ªÉ ‚Üí ∆∞u ti√™n brand ƒë√≥
- ƒê·∫∑c ƒëi·ªÉm c·ª• th·ªÉ ‚Üí match features

**QUANTITY EXTRACTION:**
- S·ªë c·ª• th·ªÉ: "mua 3 c√°i" ‚Üí 3
- M√¥ t·∫£: "v√†i c√°i" ‚Üí 3, "ƒë√¥i" ‚Üí 2, "nhi·ªÅu" ‚Üí 5
- Context: "cho team" ‚Üí 6, "c√° nh√¢n" ‚Üí 1
- Default: kh√¥ng c√≥ th√¥ng tin ‚Üí 1

**ƒê·ªäNH D·∫†NG PH·∫¢N H·ªíI JSON:**
{
  "action": "lo·∫°i h√†nh ƒë·ªông",
  "intent": "√Ω ƒë·ªãnh th·ª±c s·ª± c·ªßa user",
  "confidence": "high/medium/low",
  "analysis": {
    "userQuery": "c√¢u h·ªèi g·ªëc",
    "extractedInfo": {
      "product": "t√™n/m√¥ t·∫£ s·∫£n ph·∫©m c·∫ßn t√¨m",
      "quantity": "s·ªë l∆∞·ª£ng",
      "criteria": "ti√™u ch√≠ l·ª±a ch·ªçn",
      "context": "b·ªëi c·∫£nh s·ª≠ d·ª•ng"
    }
  },
  "execution": {
    "needsSearch": true/false,
    "searchQuery": "t·ª´ kh√≥a t√¨m ki·∫øm n·∫øu c·∫ßn",
    "productId": "id s·∫£n ph·∫©m c·ª• th·ªÉ n·∫øu c√≥",
    "quantity": s·ªë l∆∞·ª£ng cu·ªëi c√πng,
    "selectionCriteria": "ti√™u ch√≠ l·ª±a ch·ªçn"
  },
  "response": {
    "title": "Ti√™u ƒë·ªÅ ph·∫£n h·ªìi",
    "message": "N·ªôi dung ph·∫£n h·ªìi chi ti·∫øt",
    "reasoning": "L√Ω do AI ƒë∆∞a ra quy·∫øt ƒë·ªãnh n√†y"
  },
  "suggestions": ["g·ª£i √Ω 1", "g·ª£i √Ω 2"],
  "warnings": ["c·∫£nh b√°o n·∫øu c√≥"]
}

Ph√¢n t√≠ch v√† tr·∫£ v·ªÅ JSON h·ª£p l·ªá cho cart operation:`;
  }

  async executeAIAction(aiResult, userId) {
    const { action, execution, response, analysis } = aiResult;
    
    this.log(`Executing AI action: ${action}`, execution);

    try {
      switch (action) {
        case "add_product":
          return await this.handleAddProduct(userId, execution, response);

        case "search_and_add":
          return await this.handleSearchAndAdd(userId, execution, response);

        case "view_cart":
          return await this.handleViewCart(userId, response);

        case "remove_product":
          return await this.handleRemoveProduct(userId, execution, response);

        case "clear_cart":
          return await this.handleClearCart(userId, response);

        case "update_quantity":
          return await this.handleUpdateQuantity(userId, execution, response);

        default:
          return this.generateUncertaintyResponse(aiResult);
      }
    } catch (error) {
      this.log("Error executing AI action:", error);
      return `‚ùå L·ªói th·ª±c hi·ªán h√†nh ƒë·ªông: ${error.message}`;
    }
  }

  async handleAddProduct(userId, execution, response) {
    const { productId, quantity = 1 } = execution;

    if (!productId) {
      return "‚ùå Kh√¥ng x√°c ƒë·ªãnh ƒë∆∞·ª£c s·∫£n ph·∫©m c·∫ßn th√™m. Vui l√≤ng ch·ªâ r√µ t√™n ho·∫∑c ID s·∫£n ph·∫©m.";
    }

    const product = await Product.findById(productId);
    if (!product) {
      return "‚ùå Kh√¥ng t√¨m th·∫•y s·∫£n ph·∫©m. Vui l√≤ng ki·ªÉm tra l·∫°i th√¥ng tin.";
    }

    return await this.addToCart(userId, product, quantity, response);
  }

  async handleSearchAndAdd(userId, execution, response) {
    const { searchQuery, quantity = 1, selectionCriteria } = execution;

    if (!searchQuery) {
      return "‚ùå Kh√¥ng x√°c ƒë·ªãnh ƒë∆∞·ª£c t·ª´ kh√≥a t√¨m ki·∫øm. Vui l√≤ng ch·ªâ r√µ s·∫£n ph·∫©m c·∫ßn t√¨m.";
    }

    // Perform vector search
    const vectorStoreManager = VectorStoreManager.getInstance();
    const searchResults = await vectorStoreManager.similaritySearch(searchQuery, 10);

    if (!searchResults || searchResults.length === 0) {
      return `‚ùå Kh√¥ng t√¨m th·∫•y s·∫£n ph·∫©m n√†o ph√π h·ª£p v·ªõi "${searchQuery}". Vui l√≤ng th·ª≠ t·ª´ kh√≥a kh√°c.`;
    }

    // Let AI select the best product
    const selectedProduct = await this.aiSelectProduct(searchResults, selectionCriteria, searchQuery);
    
    if (!selectedProduct) {
      return this.generateProductSelectionOptions(searchResults, searchQuery);
    }

    const product = await Product.findById(selectedProduct.id);
    if (!product) {
      return "‚ùå S·∫£n ph·∫©m ƒë√£ ch·ªçn kh√¥ng t·ªìn t·∫°i. Vui l√≤ng th·ª≠ l·∫°i.";
    }

    const result = await this.addToCart(userId, product, quantity, response);
    return `${result}\n\nüéØ **L√Ω do ch·ªçn:** ${selectedProduct.reason}\nüîç **T·ª´ ${searchResults.length} k·∫øt qu·∫£ t√¨m ƒë∆∞·ª£c**`;
  }

  async aiSelectProduct(searchResults, criteria, originalQuery) {
    try {
      const selectionPrompt = `T·ª´ danh s√°ch s·∫£n ph·∫©m sau, h√£y ch·ªçn s·∫£n ph·∫©m ph√π h·ª£p nh·∫•t v·ªõi y√™u c·∫ßu:

**Y√äU C·∫¶U:** "${originalQuery}"
**TI√äU CH√ç:** "${criteria || 't·ª± ƒë·ªông'}"

**DANH S√ÅCH S·∫¢N PH·∫®M:**
${JSON.stringify(searchResults.map(r => r.metadata), null, 2)}

Tr·∫£ v·ªÅ JSON:
{
  "selectedProductId": "id s·∫£n ph·∫©m ƒë∆∞·ª£c ch·ªçn",
  "reason": "l√Ω do ch·ªçn s·∫£n ph·∫©m n√†y",
  "confidence": "high/medium/low"
}`;

      const selectionResponse = await this.llm.invoke(selectionPrompt);
      const jsonMatch = selectionResponse.content.match(/\{[\s\S]*\}/);
      
      if (jsonMatch) {
        const selection = JSON.parse(jsonMatch[0]);
        return {
          id: selection.selectedProductId,
          reason: selection.reason,
          confidence: selection.confidence
        };
      }
    } catch (error) {
      this.log("Error in AI product selection:", error);
    }

    return null;
  }

  async handleViewCart(userId, response) {
    const cart = await Cart.findOne({ user: userId }).populate('items.product');

    if (!cart || cart.items.length === 0) {
      return `üõí **${response.title || 'Gi·ªè h√†ng tr·ªëng'}**

${response.message || 'Gi·ªè h√†ng c·ªßa b·∫°n ƒëang tr·ªëng. H√£y t√¨m ki·∫øm v√† th√™m s·∫£n ph·∫©m!'}

üí° **G·ª£i √Ω:**
- "T√¨m chu·ªôt gaming" 
- "Mua tai nghe t·ªët nh·∫•t"
- "Th√™m b√†n ph√≠m c∆° v√†o gi·ªè"`;
    }

    const cartItems = cart.items.map((item, index) => {
      const product = item.product;
      const stockStatus = product && product.stock >= item.quantity ? "‚úÖ C√≤n h√†ng" : "‚ö†Ô∏è H·∫øt h√†ng";
      
      return `${index + 1}. **${item.name}**
   üí∞ ${item.price.toLocaleString("vi-VN")}ƒë x ${item.quantity} = ${(item.price * item.quantity).toLocaleString("vi-VN")}ƒë
   üìã ${stockStatus}`;
    }).join("\n\n");

    return `üõí **${response.title || 'Gi·ªè h√†ng c·ªßa b·∫°n'}**

${cartItems}

üí∞ **T·ªîNG C·ªòNG: ${cart.totalPrice.toLocaleString("vi-VN")}ƒë**
üì¶ **${cart.items.length} s·∫£n ph·∫©m**

${response.message || 'B·∫°n c√≥ th·ªÉ ti·∫øp t·ª•c mua s·∫Øm ho·∫∑c ti·∫øn h√†nh thanh to√°n!'}`;
  }

  async handleRemoveProduct(userId, execution, response) {
    const { productId, productName } = execution;
    
    const cart = await Cart.findOne({ user: userId });
    if (!cart || cart.items.length === 0) {
      return "‚ùå Gi·ªè h√†ng c·ªßa b·∫°n ƒëang tr·ªëng.";
    }

    let itemIndex = -1;
    if (productId) {
      itemIndex = cart.items.findIndex(item => item.product.toString() === productId);
    } else if (productName) {
      itemIndex = cart.items.findIndex(item => 
        item.name.toLowerCase().includes(productName.toLowerCase())
      );
    }

    if (itemIndex === -1) {
      return `‚ùå Kh√¥ng t√¨m th·∫•y s·∫£n ph·∫©m "${productName || productId}" trong gi·ªè h√†ng.`;
    }

    const removedItem = cart.items[itemIndex];
    cart.items.splice(itemIndex, 1);
    cart.totalPrice = cart.items.reduce((total, item) => total + item.price * item.quantity, 0);
    await cart.save();

    return `‚úÖ **${response.title || 'ƒê√£ x√≥a s·∫£n ph·∫©m'}**

üóëÔ∏è **ƒê√£ x√≥a:** ${removedItem.name}
üí∞ **Ti·∫øt ki·ªám:** ${(removedItem.price * removedItem.quantity).toLocaleString("vi-VN")}ƒë

üõçÔ∏è **Gi·ªè h√†ng c√≤n:** ${cart.totalPrice.toLocaleString("vi-VN")}ƒë (${cart.items.length} s·∫£n ph·∫©m)

${response.message || ''}`;
  }

  async handleClearCart(userId, response) {
    const cart = await Cart.findOne({ user: userId });
    if (!cart || cart.items.length === 0) {
      return "‚ùå Gi·ªè h√†ng c·ªßa b·∫°n ƒë√£ tr·ªëng.";
    }

    const itemCount = cart.items.length;
    const totalValue = cart.totalPrice;
    await Cart.findOneAndDelete({ user: userId });

    return `‚úÖ **${response.title || 'ƒê√£ x√≥a to√†n b·ªô gi·ªè h√†ng'}**

üóëÔ∏è **ƒê√£ x√≥a:** ${itemCount} s·∫£n ph·∫©m
üí∞ **T·ªïng gi√° tr·ªã:** ${totalValue.toLocaleString("vi-VN")}ƒë

${response.message || 'Gi·ªè h√†ng hi·ªán t·∫°i ƒë√£ tr·ªëng. B·∫°n c√≥ th·ªÉ b·∫Øt ƒë·∫ßu mua s·∫Øm m·ªõi!'}`;
  }

  async handleUpdateQuantity(userId, execution, response) {
    const { productId, quantity } = execution;
    
    const cart = await Cart.findOne({ user: userId });
    if (!cart) {
      return "‚ùå Gi·ªè h√†ng c·ªßa b·∫°n ƒëang tr·ªëng.";
    }

    const itemIndex = cart.items.findIndex(item => item.product.toString() === productId);
    if (itemIndex === -1) {
      return "‚ùå Kh√¥ng t√¨m th·∫•y s·∫£n ph·∫©m trong gi·ªè h√†ng.";
    }

    const product = await Product.findById(productId);
    if (quantity > product.stock) {
      return `‚ùå Kh√¥ng ƒë·ªß h√†ng! S·∫£n ph·∫©m ch·ªâ c√≤n ${product.stock} trong kho.`;
    }

    cart.items[itemIndex].quantity = quantity;
    cart.totalPrice = cart.items.reduce((total, item) => total + item.price * item.quantity, 0);
    await cart.save();

    return `‚úÖ **ƒê√£ c·∫≠p nh·∫≠t s·ªë l∆∞·ª£ng**

üì¶ **${cart.items[itemIndex].name}:** ${quantity} s·∫£n ph·∫©m
üí∞ **T·ªïng gi·ªè h√†ng:** ${cart.totalPrice.toLocaleString("vi-VN")}ƒë`;
  }

  async addToCart(userId, product, quantity, response) {
    if (product.stock < quantity) {
      return `‚ùå Kh√¥ng ƒë·ªß h√†ng! S·∫£n ph·∫©m "${product.name}" ch·ªâ c√≤n ${product.stock} trong kho.`;
    }

    let cart = await Cart.findOne({ user: userId });
    const effectivePrice = product.discountPrice || product.price;

    if (!cart) {
      cart = new Cart({
        user: userId,
        items: [{
          product: product._id,
          name: product.name,
          image: product.images?.[0]?.url || "",
          price: effectivePrice,
          quantity: quantity,
        }],
        totalPrice: effectivePrice * quantity,
      });
    } else {
      const existingItemIndex = cart.items.findIndex(
        item => item.product.toString() === product._id.toString()
      );

      if (existingItemIndex > -1) {
        const newQuantity = cart.items[existingItemIndex].quantity + quantity;
        if (newQuantity > product.stock) {
          return `‚ùå Kh√¥ng th·ªÉ th√™m ${quantity} s·∫£n ph·∫©m! Ch·ªâ c√≤n ${product.stock} trong kho v√† b·∫°n ƒë√£ c√≥ ${cart.items[existingItemIndex].quantity} trong gi·ªè.`;
        }
        cart.items[existingItemIndex].quantity = newQuantity;
      } else {
        cart.items.push({
          product: product._id,
          name: product.name,
          image: product.images?.[0]?.url || "",
          price: effectivePrice,
          quantity: quantity,
        });
      }

      cart.totalPrice = cart.items.reduce((total, item) => total + item.price * item.quantity, 0);
    }

    await cart.save();

    const discountText = product.discountPrice 
      ? ` (Gi·∫£m t·ª´ ${product.price.toLocaleString("vi-VN")}ƒë)`
      : "";

    return `‚úÖ **${response.title || 'ƒê√£ th√™m v√†o gi·ªè h√†ng!'}**

üõí **${product.name}**
üí∞ ${effectivePrice.toLocaleString("vi-VN")}ƒë${discountText}
üì¶ S·ªë l∆∞·ª£ng: ${quantity}
üíµ Th√†nh ti·ªÅn: ${(effectivePrice * quantity).toLocaleString("vi-VN")}ƒë

üõçÔ∏è **T·ªïng gi·ªè h√†ng:** ${cart.totalPrice.toLocaleString("vi-VN")}ƒë (${cart.items.length} s·∫£n ph·∫©m)

${response.message || 'Ti·∫øp t·ª•c mua s·∫Øm ho·∫∑c h·ªèi t√¥i ƒë·ªÉ xem gi·ªè h√†ng!'}`;
  }

  generateProductSelectionOptions(searchResults, query) {
    const topProducts = searchResults.slice(0, 3);
    
    const productList = topProducts.map((result, index) => {
      const product = result.metadata;
      const price = product.discountPrice || product.price;
      return `${index + 1}. **${product.name}** - ${product.brand}
   üí∞ ${price.toLocaleString('vi-VN')}ƒë
   ‚≠ê ${product.rating}/5 (${product.reviews} ƒë√°nh gi√°)`;
    }).join('\n\n');

    return `üîç **T√¨m th·∫•y ${searchResults.length} s·∫£n ph·∫©m cho "${query}"**

${productList}

üí° **B·∫°n mu·ªën ch·ªçn s·∫£n ph·∫©m n√†o?**
- "Ch·ªçn s·ªë 1" 
- "Mua s·∫£n ph·∫©m th·ª© 2"
- "L·∫•y c√°i r·∫ª nh·∫•t"
- "Th√™m c√°i t·ªët nh·∫•t"`;
  }

  generateUncertaintyResponse(aiResult) {
    return `ü§î **AI ch∆∞a hi·ªÉu r√µ y√™u c·∫ßu c·ªßa b·∫°n**

**C√¢u h·ªèi:** "${aiResult.analysis?.userQuery || 'N/A'}"

üí° **G·ª£i √Ω c√¢u h·ªèi r√µ r√†ng h∆°n:**
- "Mua 2 chu·ªôt gaming Logitech"
- "Th√™m tai nghe t·ªët nh·∫•t v√†o gi·ªè"
- "Xem gi·ªè h√†ng c·ªßa t√¥i"
- "X√≥a s·∫£n ph·∫©m [t√™n] kh·ªèi gi·ªè"
- "T√¨m v√† mua b√†n ph√≠m c∆° r·∫ª nh·∫•t"

üîÑ **Ho·∫∑c th·ª≠ di·ªÖn ƒë·∫°t l·∫°i y√™u c·∫ßu c·ªßa b·∫°n!**`;
  }

  fallbackResponse(query, currentCart) {
    return `ü§ñ **AI ƒëang x·ª≠ l√Ω c√¢u h·ªèi v·ªÅ gi·ªè h√†ng**

**C√¢u h·ªèi:** "${query}"
**Gi·ªè h√†ng hi·ªán t·∫°i:** ${currentCart.itemCount} s·∫£n ph·∫©m

‚ö†Ô∏è **L∆∞u √Ω:** C√≥ l·ªói trong qu√° tr√¨nh ph√¢n t√≠ch AI. Vui l√≤ng th·ª≠ l·∫°i v·ªõi c√¢u h·ªèi c·ª• th·ªÉ h∆°n.

üí° **V√≠ d·ª•:**
- "Mua chu·ªôt gaming"
- "Th√™m 3 tai nghe v√†o gi·ªè"  
- "Xem gi·ªè h√†ng"
- "X√≥a s·∫£n ph·∫©m X"`;
  }

  isValidObjectId(id) {
    return mongoose.Types.ObjectId.isValid(id) && (String(new mongoose.Types.ObjectId(id)) === id);
  }
}

module.exports = AISmartCartTool;
