const { StructuredTool } = require("@langchain/core/tools");
const { z } = require("zod");
const mongoose = require("mongoose");
const Order = require("../../../models/orderModel");
const Cart = require("../../../models/cartModel");
const User = require("../../../models/userModel");
const Product = require("../../../models/productModel");
const ghnService = require("../../ghnService");

/**
 * OptimizedAIOrderTool - Simplified order management tool
 * Eliminates AI processing loops by using direct pattern matching and deterministic logic
 */
class OptimizedAIOrderTool extends StructuredTool {
  constructor(userContext = null) {
    super();
    this.name = "optimized_ai_order_tool";
    this.description = `Qu·∫£n l√Ω ƒë∆°n h√†ng th√¥ng minh t·ªëi ∆∞u. S·ª≠ d·ª•ng khi ng∆∞·ªùi d√πng mu·ªën ƒë·∫∑t h√†ng, thanh to√°n, xem ƒë∆°n h√†ng, t√≠nh ph√≠ ship. T·ª´ kh√≥a: ƒë·∫∑t h√†ng, thanh to√°n, COD, VNPay, ph√≠ ship, ƒë∆°n h√†ng, order, checkout. Ch·ªâ ho·∫°t ƒë·ªông khi ƒë√£ ƒëƒÉng nh·∫≠p.`;
    this.userContext = userContext;
    this.debugMode = process.env.CHATBOT_DEBUG === "true";
    
    this.schema = z.object({
      query: z.string().describe("User's natural language query about order operations."),
    });

    // Pre-defined patterns for direct matching - NO AI NEEDED
    this.patterns = {
      startCheckout: [
        /ƒë·∫∑t\s*h√†ng/i,
        /mua\s*h√†ng/i,
        /checkout/i,
        /thanh\s*to√°n/i,
        /b·∫Øt\s*ƒë·∫ßu.*ƒë·∫∑t/i
      ],
      calculateShipping: [
        /ph√≠\s*ship/i,
        /ph√≠\s*v·∫≠n\s*chuy·ªÉn/i,
        /t√≠nh.*ship/i,
        /shipping/i
      ],
      selectPaymentCOD: [
        /cod/i,
        /thanh\s*to√°n.*khi.*nh·∫≠n/i,
        /ch·ªçn.*cod/i
      ],
      selectPaymentVNPay: [
        /vnpay/i,
        /thanh\s*to√°n.*online/i,
        /ch·ªçn.*vnpay/i
      ],
      confirmOrder: [
        /x√°c\s*nh·∫≠n.*ƒë∆°n/i,
        /ƒë·ªìng\s*√Ω.*ƒë·∫∑t/i,
        /ho√†n\s*t·∫•t/i,
        /confirm/i
      ],
      checkOrderStatus: [
        /ki·ªÉm\s*tra.*ƒë∆°n/i,
        /tr·∫°ng\s*th√°i.*ƒë∆°n/i,
        /ƒë∆°n\s*h√†ng.*c·ªßa.*t√¥i/i,
        /order.*status/i
      ],
      viewOrderDetails: [
        /chi\s*ti·∫øt.*ƒë∆°n/i,
        /xem.*ƒë∆°n/i,
        /order.*details/i
      ]
    };
  }

  log(message, ...args) {
    if (this.debugMode) {
      console.log(`[OptimizedAIOrderTool] ${message}`, ...args);
    }
  }

  updateUserContext(userContext) {
    this.log(`Updating userContext - old: ${this.userContext ? this.userContext.getUserId() : 'null'}, new: ${userContext ? userContext.getUserId() : 'null'}`);
    this.userContext = userContext;
  }

  // MAIN ENTRY POINT - NO AI PROCESSING
  async _call({ query }) {
    try {
      // Input validation
      if (!query || typeof query !== 'string') {
        this.log("Invalid query input:", query);
        return "‚ùå Y√™u c·∫ßu kh√¥ng h·ª£p l·ªá. Vui l√≤ng th·ª≠ l·∫°i." + "\n\n[TASK_COMPLETED: Invalid request]";
      }

      const userId = this.userContext ? this.userContext.getUserId() : null;
      
      if (!userId) {
        this.log(`No userId found - authentication required`);
        return "üîí ƒê·ªÉ ƒë·∫∑t h√†ng, b·∫°n c·∫ßn ƒëƒÉng nh·∫≠p v√†o t√†i kho·∫£n." + "\n\n[TASK_COMPLETED: Authentication required]";
      }

      this.log(`Processing query: "${query}" for userId: ${userId}`);
      
      // DIRECT PATTERN MATCHING - NO AI NEEDED
      const action = this.detectAction(query);
      this.log(`Detected action:`, JSON.stringify(action));

      // Get context data only when needed
      const contextData = await this.getContextData(userId, action);
      this.log(`Context data loaded:`, Object.keys(contextData));

      // DIRECT HANDLER EXECUTION
      return await this.executeDirectAction(action, userId, contextData, query);

    } catch (error) {
      this.log("Error in OptimizedAIOrderTool:", error);
      return `‚ùå L·ªói x·ª≠ l√Ω ƒë∆°n h√†ng: ${error.message}. Vui l√≤ng th·ª≠ l·∫°i sau.` + "\n\n[TASK_COMPLETED: Order processing error]";
    }
  }

  // PATTERN MATCHING - DETERMINISTIC, NO AI
  detectAction(query) {
    const lowerQuery = query.toLowerCase();
    
    // Check for order ID in query for specific actions
    const orderIdMatch = query.match(/([a-f0-9]{24})/i);
    
    if (orderIdMatch && mongoose.Types.ObjectId.isValid(orderIdMatch[1])) {
      if (this.patterns.viewOrderDetails.some(pattern => pattern.test(lowerQuery))) {
        return { type: 'viewOrderDetails', orderId: orderIdMatch[1] };
      }
      if (this.patterns.checkOrderStatus.some(pattern => pattern.test(lowerQuery))) {
        return { type: 'checkOrderStatus', orderId: orderIdMatch[1] };
      }
    }

    // Pattern matching for actions - prioritize specific actions first
    const actionPriority = [
      'confirmOrder',
      'selectPaymentCOD', 
      'selectPaymentVNPay',
      'calculateShipping',
      'checkOrderStatus',
      'viewOrderDetails',
      'startCheckout'
    ];
    
    for (const actionType of actionPriority) {
      if (this.patterns[actionType] && this.patterns[actionType].some(pattern => pattern.test(lowerQuery))) {
        return { type: actionType };
      }
    }

    // Default action based on context
    return { type: 'startCheckout' };
  }

  // SMART CONTEXT LOADING - Only load what's needed
  async getContextData(userId, action) {
    const data = {};
    
    // Always need user info for most actions
    if (['startCheckout', 'confirmOrder', 'calculateShipping', 'selectPaymentCOD', 'selectPaymentVNPay'].includes(action.type)) {
      data.userInfo = await this.getUserInfo(userId);
    }
    
    // Load cart only for checkout-related actions
    if (['startCheckout', 'confirmOrder'].includes(action.type)) {
      data.currentCart = await this.getCurrentCart(userId);
    }
    
    // Load recent orders only for order-related actions
    if (['checkOrderStatus', 'viewOrderDetails'].includes(action.type)) {
      data.recentOrders = await this.getRecentOrders(userId);
    }

    return data;
  }

  // DIRECT ACTION EXECUTION - NO AI LOOPS
  async executeDirectAction(action, userId, contextData, originalQuery) {
    const { type, orderId, paymentMethod } = action;
    
    try {
      switch (type) {
        case 'startCheckout':
          return await this.handleStartCheckout(userId, contextData.currentCart, contextData.userInfo);
        
        case 'calculateShipping':
          return await this.handleCalculateShipping(userId, contextData.userInfo);
        
        case 'selectPaymentCOD':
          return await this.handleSelectPaymentMethod(userId, 'COD');
        
        case 'selectPaymentVNPay':
          return await this.handleSelectPaymentMethod(userId, 'VNPay');
        
        case 'confirmOrder':
          return await this.handleConfirmOrder(userId, contextData.currentCart, contextData.userInfo);
        
        case 'checkOrderStatus':
          return await this.handleCheckOrderStatus(userId, orderId);
        
        case 'viewOrderDetails':
          return await this.handleViewOrderDetails(userId, orderId);
        
        default:
          return this.handleGeneralInfo();
      }
    } catch (error) {
      this.log(`Error in executeDirectAction for ${type}:`, error);
      return `‚ùå L·ªói x·ª≠ l√Ω y√™u c·∫ßu: ${error.message}. Vui l√≤ng th·ª≠ l·∫°i.` + "\n\n[TASK_COMPLETED: Request processing error]";
    }
  }

  // EXISTING METHODS - UNCHANGED BUT OPTIMIZED
  async getCurrentCart(userId) {
    try {
      if (!userId || !mongoose.Types.ObjectId.isValid(userId)) {
        this.log("Invalid userId for getCurrentCart:", userId);
        return { isEmpty: true, itemCount: 0, totalPrice: 0, items: [] };
      }

      const cart = await Cart.findOne({ user: userId }).populate('items.product');
      if (!cart || cart.items.length === 0) {
        return { isEmpty: true, itemCount: 0, totalPrice: 0, items: [] };
      }

      // Filter out items with null/undefined products
      const validItems = cart.items.filter(item => item.product && item.product._id);
      
      if (validItems.length === 0) {
        return { isEmpty: true, itemCount: 0, totalPrice: 0, items: [] };
      }

      return {
        isEmpty: false,
        itemCount: validItems.length,
        totalPrice: cart.totalPrice || 0,
        items: validItems.map(item => ({
          productId: item.product._id,
          name: item.name, // Use cart item name, not product name
          quantity: item.quantity || 1,
          price: item.price, // Use cart item price, not product price
          image: item.image, // Use cart item image, not product image
          stock: item.product.stock || 0
        }))
      };
    } catch (error) {
      this.log("Error getting cart:", error);
      return { isEmpty: true, itemCount: 0, totalPrice: 0, items: [] };
    }
  }

  async getUserInfo(userId) {
    try {
      if (!userId || !mongoose.Types.ObjectId.isValid(userId)) {
        this.log("Invalid userId for getUserInfo:", userId);
        return { hasAddress: false, preferredPaymentMethod: 'COD', name: 'Kh√°ch h√†ng' };
      }

      const user = await User.findById(userId);
      if (!user) {
        this.log("User not found:", userId);
        return { hasAddress: false, preferredPaymentMethod: 'COD', name: 'Kh√°ch h√†ng' };
      }

      return {
        name: user.name || 'Kh√°ch h√†ng',
        email: user.email || '',
        phone: user.phone || '',
        hasAddress: !!(user.address && user.address.street && user.address.province),
        address: user.address || null,
        preferredPaymentMethod: user.chatbotPreferences?.preferredPaymentMethod || 'COD'
      };
    } catch (error) {
      this.log("Error getting user info:", error);
      return { hasAddress: false, preferredPaymentMethod: 'COD', name: 'Kh√°ch h√†ng' };
    }
  }

  async getRecentOrders(userId, limit = 3) {
    try {
      const orders = await Order.find({ user: userId })
        .sort({ createdAt: -1 })
        .limit(limit)
        .select('_id status totalPrice createdAt');
      
      return orders.map(order => ({
        id: order._id,
        status: order.status,
        totalPrice: order.totalPrice,
        createdAt: order.createdAt
      }));
    } catch (error) {
      this.log("Error getting recent orders:", error);
      return [];
    }
  }

  // OPTIMIZED HANDLERS - DIRECT RESPONSES
  async handleStartCheckout(userId, currentCart, userInfo) {
    try {
      if (!currentCart || currentCart.isEmpty) {
        return "üõí Gi·ªè h√†ng c·ªßa b·∫°n ƒëang tr·ªëng. H√£y th√™m s·∫£n ph·∫©m v√†o gi·ªè h√†ng tr∆∞·ªõc khi ƒë·∫∑t h√†ng.\n\nüí° B·∫°n c√≥ th·ªÉ n√≥i: 'Mua chu·ªôt gaming' ho·∫∑c 'Th√™m b√†n ph√≠m c∆° v√†o gi·ªè'" + "\n\n[TASK_COMPLETED: Empty cart]";
      }

      // Validate cart items
      if (!currentCart.items || !Array.isArray(currentCart.items)) {
        this.log("Invalid cart items structure:", currentCart);
        return "üõí Gi·ªè h√†ng kh√¥ng h·ª£p l·ªá. Vui l√≤ng th·ª≠ l·∫°i." + "\n\n[TASK_COMPLETED: Invalid cart]";
      }

      // Check stock availability
      const stockIssues = currentCart.items.filter(item => 
        item && item.quantity && item.stock !== undefined && item.quantity > item.stock
      );
      if (stockIssues.length > 0) {
        const issueList = stockIssues.map(item => `- ${item.name || 'S·∫£n ph·∫©m'}: c√≤n ${item.stock}, b·∫°n mu·ªën ${item.quantity}`).join('\n');
        return `‚ö†Ô∏è M·ªôt s·ªë s·∫£n ph·∫©m trong gi·ªè h√†ng kh√¥ng ƒë·ªß s·ªë l∆∞·ª£ng:
${issueList}

Vui l√≤ng c·∫≠p nh·∫≠t s·ªë l∆∞·ª£ng ho·∫∑c x√≥a s·∫£n ph·∫©m h·∫øt h√†ng.` + "\n\n[TASK_COMPLETED: Stock quantity issues]";
      }

      let response = `üõçÔ∏è **B·∫Øt ƒë·∫ßu ƒë·∫∑t h√†ng**\n\n`;
      response += `üì¶ **S·∫£n ph·∫©m trong gi·ªè (${currentCart.itemCount || currentCart.items.length} m√≥n):**\n`;
      
      currentCart.items.forEach(item => {
        if (item && item.name && item.quantity && item.price) {
          response += `‚Ä¢ ${item.name} x${item.quantity} - ${new Intl.NumberFormat('vi-VN', { style: 'currency', currency: 'VND' }).format(item.price * item.quantity)}\n`;
        }
      });
      
      response += `\nüí∞ **T·∫°m t√≠nh:** ${new Intl.NumberFormat('vi-VN', { style: 'currency', currency: 'VND' }).format(currentCart.totalPrice || 0)}\n\n`;

      if (!userInfo || !userInfo.hasAddress) {
        response += `üìç **C·∫ßn c·∫≠p nh·∫≠t ƒë·ªãa ch·ªâ giao h√†ng**\nVui l√≤ng c·∫≠p nh·∫≠t ƒë·ªãa ch·ªâ trong t√†i kho·∫£n ƒë·ªÉ t√≠nh ph√≠ v·∫≠n chuy·ªÉn.\n\n`;
      } else {
        try {
          const shippingFee = await this.calculateShippingFee(userInfo.address);
          response += `üöö **Ph√≠ v·∫≠n chuy·ªÉn:** ${new Intl.NumberFormat('vi-VN', { style: 'currency', currency: 'VND' }).format(shippingFee)}\n`;
          response += `üí≥ **T·ªïng c·ªông:** ${new Intl.NumberFormat('vi-VN', { style: 'currency', currency: 'VND' }).format((currentCart.totalPrice || 0) + shippingFee)}\n\n`;
        } catch (error) {
          this.log("Error calculating shipping in checkout:", error);
          response += `üöö **Ph√≠ v·∫≠n chuy·ªÉn:** ƒêang t√≠nh to√°n...\n\n`;
        }
      }

      response += `üí≥ **Ph∆∞∆°ng th·ª©c thanh to√°n:**\n`;
      response += `‚Ä¢ COD (Thanh to√°n khi nh·∫≠n h√†ng)\n`;
      response += `‚Ä¢ VNPay (Thanh to√°n online)\n\n`;
      response += `‚úÖ ƒê·ªÉ ti·∫øp t·ª•c, h√£y ch·ªçn: "Thanh to√°n b·∫±ng COD" ho·∫∑c "Thanh to√°n qua VNPay"`;

      return response + "\n\n[TASK_COMPLETED: Order checkout initiated]";
    } catch (error) {
      this.log("Error in handleStartCheckout:", error);
      return "‚ùå L·ªói khi b·∫Øt ƒë·∫ßu ƒë·∫∑t h√†ng. Vui l√≤ng th·ª≠ l·∫°i." + "\n\n[TASK_COMPLETED: Checkout start error]";
    }
  }

  async handleCalculateShipping(userId, userInfo) {
    try {
      if (!userInfo || !userInfo.hasAddress) {
        return "üìç ƒê·ªÉ t√≠nh ph√≠ v·∫≠n chuy·ªÉn, b·∫°n c·∫ßn c·∫≠p nh·∫≠t ƒë·ªãa ch·ªâ giao h√†ng trong t√†i kho·∫£n.\n\nüí° Vui l√≤ng v√†o T√†i kho·∫£n > ƒê·ªãa ch·ªâ ƒë·ªÉ c·∫≠p nh·∫≠t th√¥ng tin." + "\n\n[TASK_COMPLETED: Address required for shipping]";
      }

      if (!userInfo.address) {
        this.log("User has hasAddress=true but no address object:", userInfo);
        return "üìç ƒê·ªãa ch·ªâ giao h√†ng kh√¥ng h·ª£p l·ªá. Vui l√≤ng c·∫≠p nh·∫≠t l·∫°i ƒë·ªãa ch·ªâ." + "\n\n[TASK_COMPLETED: Invalid address]";
      }

      this.log("Calculating shipping for address:", userInfo.address);
      const shippingFee = await this.calculateShippingFee(userInfo.address);
      const estimatedDays = 2;
      
      const provinceName = userInfo.address.province?.name || userInfo.address.province || 'ƒë·ªãa ch·ªâ c·ªßa b·∫°n';
      const wardName = userInfo.address.ward?.name || userInfo.address.ward || '';
      const districtName = userInfo.address.district?.name || userInfo.address.district || '';
      const street = userInfo.address.street || '';
      
      return `üöö **Ph√≠ v·∫≠n chuy·ªÉn ƒë·∫øn ${provinceName}:**\n\n` +
             `üí∞ **Ph√≠ ship:** ${new Intl.NumberFormat('vi-VN', { style: 'currency', currency: 'VND' }).format(shippingFee)}\n` +
             `‚è±Ô∏è **Th·ªùi gian giao h√†ng:** ${estimatedDays}-3 ng√†y l√†m vi·ªác\n` +
             `üìç **ƒê·ªãa ch·ªâ:** ${[street, wardName, districtName, provinceName].filter(Boolean).join(', ')}` +
             "\n\n[TASK_COMPLETED: Shipping calculated]";
    } catch (error) {
      this.log("Error calculating shipping:", error);
      return "‚ùå Kh√¥ng th·ªÉ t√≠nh ph√≠ v·∫≠n chuy·ªÉn l√∫c n√†y. Vui l√≤ng th·ª≠ l·∫°i sau." + "\n\n[TASK_COMPLETED: Shipping calculation failed]";
    }
  }

  async handleSelectPaymentMethod(userId, paymentMethod) {
    try {
      if (!paymentMethod || !['COD', 'VNPay'].includes(paymentMethod)) {
        return "üí≥ **Ch·ªçn ph∆∞∆°ng th·ª©c thanh to√°n:**\n\n" +
               "‚Ä¢ **COD** - Thanh to√°n khi nh·∫≠n h√†ng (ti·ªán l·ª£i, kh√¥ng c·∫ßn th·∫ª)\n" +
               "‚Ä¢ **VNPay** - Thanh to√°n online (nhanh ch√≥ng, b·∫£o m·∫≠t)\n\n" +
               "H√£y n√≥i: 'T√¥i ch·ªçn COD' ho·∫∑c 'Thanh to√°n qua VNPay'" + "\n\n[TASK_COMPLETED: Payment method options shown]";
      }

      if (!userId || !mongoose.Types.ObjectId.isValid(userId)) {
        this.log("Invalid userId for payment method selection:", userId);
        return "‚ùå Phi√™n ƒëƒÉng nh·∫≠p kh√¥ng h·ª£p l·ªá. Vui l√≤ng ƒëƒÉng nh·∫≠p l·∫°i." + "\n\n[TASK_COMPLETED: Invalid session]";
      }

      // Update user preference
      try {
        const updateResult = await User.findByIdAndUpdate(userId, {
          'chatbotPreferences.preferredPaymentMethod': paymentMethod
        }, { new: true });
        
        if (!updateResult) {
          this.log("User not found when updating payment preference:", userId);
        } else {
          this.log("Payment preference updated successfully for user:", userId);
        }
      } catch (error) {
        this.log("Error updating payment preference:", error);
      }

      const methodName = paymentMethod === 'COD' ? 'Thanh to√°n khi nh·∫≠n h√†ng (COD)' : 'Thanh to√°n online qua VNPay';
      return `‚úÖ **ƒê√£ ch·ªçn ph∆∞∆°ng th·ª©c thanh to√°n:** ${methodName}\n\n` +
             `üéØ ƒê·ªÉ ho√†n t·∫•t ƒë·∫∑t h√†ng, h√£y n√≥i: "T√¥i ƒë·ªìng √Ω ƒë·∫∑t h√†ng" ho·∫∑c "X√°c nh·∫≠n ƒë∆°n h√†ng"` +
             "\n\n[TASK_COMPLETED: Payment method selected]";
    } catch (error) {
      this.log("Error in handleSelectPaymentMethod:", error);
      return "‚ùå L·ªói khi ch·ªçn ph∆∞∆°ng th·ª©c thanh to√°n. Vui l√≤ng th·ª≠ l·∫°i." + "\n\n[TASK_COMPLETED: Payment method selection error]";
    }
  }

  async handleConfirmOrder(userId, currentCart, userInfo) {
    try {
      if (!currentCart || currentCart.isEmpty) {
        return "üõí Gi·ªè h√†ng tr·ªëng. Vui l√≤ng th√™m s·∫£n ph·∫©m tr∆∞·ªõc khi ƒë·∫∑t h√†ng." + "\n\n[TASK_COMPLETED: Empty cart for order]";
      }

      if (!userInfo || !userInfo.hasAddress) {
        return "üìç Vui l√≤ng c·∫≠p nh·∫≠t ƒë·ªãa ch·ªâ giao h√†ng tr∆∞·ªõc khi ƒë·∫∑t h√†ng." + "\n\n[TASK_COMPLETED: Address required for order]";
      }

      if (!userInfo.address) {
        this.log("User has hasAddress=true but no address object:", userInfo);
        return "üìç ƒê·ªãa ch·ªâ giao h√†ng kh√¥ng h·ª£p l·ªá. Vui l√≤ng c·∫≠p nh·∫≠t l·∫°i ƒë·ªãa ch·ªâ." + "\n\n[TASK_COMPLETED: Invalid address for order]";
      }

      // Validate cart items
      if (!currentCart.items || !Array.isArray(currentCart.items) || currentCart.items.length === 0) {
        return "üõí Gi·ªè h√†ng kh√¥ng c√≥ s·∫£n ph·∫©m h·ª£p l·ªá." + "\n\n[TASK_COMPLETED: No valid cart items]";
      }

      // Ki·ªÉm tra xem ƒë√£ ch·ªçn ph∆∞∆°ng th·ª©c thanh to√°n ch∆∞a
      if (!userInfo.preferredPaymentMethod) {
        return `üí≥ **Vui l√≤ng ch·ªçn ph∆∞∆°ng th·ª©c thanh to√°n tr∆∞·ªõc khi ƒë·∫∑t h√†ng:**\n\n` +
               `‚Ä¢ **COD** - Thanh to√°n khi nh·∫≠n h√†ng\n` +
               `‚Ä¢ **VNPay** - Thanh to√°n online\n\n` +
               `H√£y n√≥i: "T√¥i ch·ªçn COD" ho·∫∑c "Thanh to√°n qua VNPay"` +
               "\n\n[TASK_COMPLETED: payment_method_required]";
      }

      // Calculate shipping fee
      const shippingFee = await this.calculateShippingFee(userInfo.address);
      const paymentMethod = userInfo.preferredPaymentMethod;
      
      // Check stock again before creating order
      const stockIssues = [];
      for (const item of currentCart.items) {
        if (!item || !item.productId) {
          this.log("Invalid cart item:", item);
          continue;
        }
        
        const product = await Product.findById(item.productId);
        if (!product || product.stock < item.quantity) {
          stockIssues.push(item.name || 'S·∫£n ph·∫©m kh√¥ng x√°c ƒë·ªãnh');
        }
      }

      if (stockIssues.length > 0) {
        return `‚ö†Ô∏è S·∫£n ph·∫©m sau ƒë√£ h·∫øt h√†ng: ${stockIssues.join(', ')}. Vui l√≤ng c·∫≠p nh·∫≠t gi·ªè h√†ng.` + "\n\n[TASK_COMPLETED: Out of stock items]";
      }

      // Filter valid items for order creation
      const validItems = currentCart.items.filter(item => 
        item && item.productId && item.name && item.quantity > 0 && item.price > 0
      );

      if (validItems.length === 0) {
        return "üõí Kh√¥ng c√≥ s·∫£n ph·∫©m h·ª£p l·ªá ƒë·ªÉ t·∫°o ƒë∆°n h√†ng." + "\n\n[TASK_COMPLETED: No valid products for order]";
      }

      // Create order
      const orderData = {
        user: userId,
        orderItems: validItems.map(item => ({
          name: item.name,
          quantity: item.quantity,
          image: item.image || '',
          price: item.price,
          product: item.productId
        })),
        shippingAddress: userInfo.address,
        paymentMethod: paymentMethod,
        taxPrice: 0,
        shippingPrice: shippingFee,
        totalPrice: (currentCart.totalPrice || 0) + shippingFee,
        chatbotOrder: true,
        orderSource: 'chatbot'
      };

      this.log("Creating order with data:", { ...orderData, orderItems: orderData.orderItems.length + ' items' });
      const order = await Order.create(orderData);
      this.log("Order created successfully:", order._id);

      // Update product stock
      for (const item of validItems) {
        try {
          await Product.findByIdAndUpdate(item.productId, {
            $inc: { stock: -item.quantity, sold: item.quantity }
          });
        } catch (stockError) {
          this.log("Error updating stock for product:", item.productId, stockError);
        }
      }

      // Clear cart
      try {
        await Cart.findOneAndDelete({ user: userId });
      } catch (cartError) {
        this.log("Error clearing cart:", cartError);
      }

      const wardName = userInfo.address.ward?.name || userInfo.address.ward || '';
      const street = userInfo.address.street || '';
      
      let response = `üéâ **ƒê·∫∑t h√†ng th√†nh c√¥ng!**\n\n`;
      response += `üìã **M√£ ƒë∆°n h√†ng:** ${order._id}\n`;
      response += `üí∞ **T·ªïng ti·ªÅn:** ${new Intl.NumberFormat('vi-VN', { style: 'currency', currency: 'VND' }).format(order.totalPrice)}\n`;
      response += `üí≥ **Thanh to√°n:** ${paymentMethod === 'COD' ? 'Khi nh·∫≠n h√†ng' : 'VNPay'}\n`;
      response += `üìç **Giao ƒë·∫øn:** ${[street, wardName].filter(Boolean).join(', ')}\n`;
      response += `‚è±Ô∏è **D·ª± ki·∫øn giao:** 2-3 ng√†y l√†m vi·ªác\n\n`;
      
      if (paymentMethod === 'VNPay') {
        response += `üîó **Link thanh to√°n VNPay s·∫Ω ƒë∆∞·ª£c g·ª≠i qua email.**\n\n`;
      }
      
      response += `üìû **C·∫ßn h·ªó tr·ª£?** Li√™n h·ªá hotline ho·∫∑c n√≥i "Ki·ªÉm tra ƒë∆°n h√†ng ${order._id}"`;

      return response + "\n\n[TASK_COMPLETED: Order confirmed successfully]";

    } catch (error) {
      this.log("Error confirming order:", error);
      return `‚ùå L·ªói t·∫°o ƒë∆°n h√†ng: ${error.message}. Vui l√≤ng th·ª≠ l·∫°i.` + "\n\n[TASK_COMPLETED: Order creation error]";
    }
  }

  async handleCheckOrderStatus(userId, orderId) {
    try {
      let orders;
      
      if (orderId) {
        // Validate orderId
        if (!mongoose.Types.ObjectId.isValid(orderId)) {
          return `‚ùå M√£ ƒë∆°n h√†ng "${orderId}" kh√¥ng h·ª£p l·ªá. Vui l√≤ng ki·ªÉm tra l·∫°i.` + "\n\n[TASK_COMPLETED: Invalid order ID format]";
        }
        
        const order = await Order.findOne({ _id: orderId, user: userId });
        if (!order) {
          return `‚ùå Kh√¥ng t√¨m th·∫•y ƒë∆°n h√†ng ${orderId} ho·∫∑c b·∫°n kh√¥ng c√≥ quy·ªÅn xem ƒë∆°n h√†ng n√†y.` + "\n\n[TASK_COMPLETED: Order not found or no permission]";
        }
        orders = [order];
      } else {
        orders = await Order.find({ user: userId })
          .sort({ createdAt: -1 })
          .limit(3);
      }

      if (orders.length === 0) {
        return "üì¶ B·∫°n ch∆∞a c√≥ ƒë∆°n h√†ng n√†o. H√£y mua s·∫Øm ngay!" + "\n\n[TASK_COMPLETED: No orders found]";
      }

      let response = orderId ? `üìã **Chi ti·∫øt ƒë∆°n h√†ng ${orderId}:**\n\n` : `üì¶ **ƒê∆°n h√†ng g·∫ßn ƒë√¢y:**\n\n`;
      
      orders.forEach((order, index) => {
        if (order && order._id) {
          const statusEmoji = this.getStatusEmoji(order.status);
          const statusText = this.getStatusText(order.status);
          
          response += `${statusEmoji} **ƒê∆°n ${order._id}**\n`;
          response += `üìÖ ${new Date(order.createdAt).toLocaleDateString('vi-VN')}\n`;
          response += `üí∞ ${new Intl.NumberFormat('vi-VN', { style: 'currency', currency: 'VND' }).format(order.totalPrice || 0)}\n`;
          response += `üìä Tr·∫°ng th√°i: ${statusText}\n`;
          
          if (order.trackingNumber) {
            response += `üöö M√£ v·∫≠n ƒë∆°n: ${order.trackingNumber}\n`;
          }
          
          if (index < orders.length - 1) response += `\n`;
        }
      });

      return response + "\n\n[TASK_COMPLETED: Order status checked]";

    } catch (error) {
      this.log("Error checking order status:", error);
      return `‚ùå L·ªói ki·ªÉm tra ƒë∆°n h√†ng: ${error.message}. Vui l√≤ng th·ª≠ l·∫°i.` + "\n\n[TASK_COMPLETED: Order status check error]";
    }
  }

  async handleViewOrderDetails(userId, orderId) {
    try {
      if (!orderId) {
        return "üîç Vui l√≤ng cung c·∫•p m√£ ƒë∆°n h√†ng. V√≠ d·ª•: 'Xem chi ti·∫øt ƒë∆°n h√†ng 123456'" + "\n\n[TASK_COMPLETED: Order ID required]";
      }

      // Validate orderId
      if (!mongoose.Types.ObjectId.isValid(orderId)) {
        return `‚ùå M√£ ƒë∆°n h√†ng "${orderId}" kh√¥ng h·ª£p l·ªá. Vui l√≤ng ki·ªÉm tra l·∫°i.` + "\n\n[TASK_COMPLETED: Invalid order ID for details]";
      }

      this.log(`Viewing order details for orderId: ${orderId}, userId: ${userId}`);
      const order = await Order.findOne({ _id: orderId, user: userId })
        .populate('orderItems.product', 'name images');
      
      if (!order) {
        return `‚ùå Kh√¥ng t√¨m th·∫•y ƒë∆°n h√†ng ${orderId}.` + "\n\n[TASK_COMPLETED: Order details not found]";
      }

      const statusEmoji = this.getStatusEmoji(order.status);
      const statusText = this.getStatusText(order.status);
      
      let response = `üìã **Chi ti·∫øt ƒë∆°n h√†ng ${order._id}**\n\n`;
      response += `üìÖ **Ng√†y ƒë·∫∑t:** ${new Date(order.createdAt).toLocaleString('vi-VN')}\n`;
      response += `${statusEmoji} **Tr·∫°ng th√°i:** ${statusText}\n`;
      response += `üí≥ **Thanh to√°n:** ${order.paymentMethod}\n\n`;
      
      if (order.orderItems && order.orderItems.length > 0) {
        response += `üì¶ **S·∫£n ph·∫©m:**\n`;
        order.orderItems.forEach(item => {
          if (item && item.name && item.quantity && item.price) {
            response += `‚Ä¢ ${item.name} x${item.quantity} - ${new Intl.NumberFormat('vi-VN', { style: 'currency', currency: 'VND' }).format(item.price * item.quantity)}\n`;
          }
        });
      } else {
        response += `üì¶ **S·∫£n ph·∫©m:** Kh√¥ng c√≥ th√¥ng tin s·∫£n ph·∫©m\n`;
      }
      
      response += `\nüí∞ **T·ªïng ti·ªÅn:** ${new Intl.NumberFormat('vi-VN', { style: 'currency', currency: 'VND' }).format(order.totalPrice || 0)}\n`;
      response += `üöö **Ph√≠ ship:** ${new Intl.NumberFormat('vi-VN', { style: 'currency', currency: 'VND' }).format(order.shippingPrice || 0)}\n\n`;
      
      if (order.shippingAddress) {
        const address = order.shippingAddress;
        const addressParts = [
          address.street,
          address.ward?.name || address.ward,
          address.district?.name || address.district,
          address.province?.name || address.province
        ].filter(Boolean);
        
        response += `üìç **ƒê·ªãa ch·ªâ giao h√†ng:**\n${addressParts.join(', ')}\n\n`;
      }
      
      if (order.trackingNumber) {
        response += `üöö **M√£ v·∫≠n ƒë∆°n:** ${order.trackingNumber}\n`;
      }
      
      if (order.notes) {
        response += `üìù **Ghi ch√∫:** ${order.notes}\n`;
      }

      return response + "\n\n[TASK_COMPLETED: Order details viewed]";

    } catch (error) {
      this.log("Error viewing order details:", error);
      return `‚ùå L·ªói xem chi ti·∫øt ƒë∆°n h√†ng: ${error.message}. Vui l√≤ng th·ª≠ l·∫°i.` + "\n\n[TASK_COMPLETED: Order details view error]";
    }
  }

  handleGeneralInfo() {
    return `üõçÔ∏è **H∆∞·ªõng d·∫´n ƒë·∫∑t h√†ng t·∫°i Gaming Gear Shop:**\n\n` +
           `1Ô∏è‚É£ **Th√™m s·∫£n ph·∫©m v√†o gi·ªè:** "Mua chu·ªôt gaming"\n` +
           `2Ô∏è‚É£ **Xem gi·ªè h√†ng:** "Xem gi·ªè h√†ng"\n` +
           `3Ô∏è‚É£ **ƒê·∫∑t h√†ng:** "T√¥i mu·ªën ƒë·∫∑t h√†ng"\n` +
           `4Ô∏è‚É£ **Ch·ªçn thanh to√°n:** COD ho·∫∑c VNPay\n` +
           `5Ô∏è‚É£ **X√°c nh·∫≠n:** "ƒê·ªìng √Ω ƒë·∫∑t h√†ng"\n\n` +
           `üí≥ **Ph∆∞∆°ng th·ª©c thanh to√°n:**\n` +
           `‚Ä¢ COD: Thanh to√°n khi nh·∫≠n h√†ng\n` +
           `‚Ä¢ VNPay: Thanh to√°n online an to√†n\n\n` +
           `üöö **Giao h√†ng:** 2-3 ng√†y to√†n qu·ªëc\n` +
           `üìû **H·ªó tr·ª£:** Li√™n h·ªá hotline 24/7` +
           "\n\n[TASK_COMPLETED: General info provided]";
  }

  async calculateShippingFee(address) {
    try {
      // Validate address structure
      if (!address || !address.district || !address.ward) {
        this.log("Invalid address structure for shipping calculation:", address);
        return 30000; // Default shipping fee
      }

      const shippingParams = {
        to_district_id: address.district.id || address.district,
        to_ward_code: address.ward.code || address.ward,
        weight: 500,
        length: 30,
        width: 20,
        height: 10
      };

      this.log("Calculating shipping with params:", shippingParams);
      
      const result = await ghnService.calculateShippingFee(shippingParams);
      
      const shippingFee = result?.data?.total || result?.total || 30000;
      this.log("Calculated shipping fee:", shippingFee);
      
      return shippingFee;
    } catch (error) {
      this.log("Error calculating shipping fee:", error);
      return 30000; // Default fallback fee
    }
  }

  getStatusEmoji(status) {
    const statusMap = {
      'Processing': '‚è≥',
      'Shipped': 'üöö',
      'Delivered': '‚úÖ',
      'Cancelled': '‚ùå',
      'pending': '‚è≥',
      'processing': 'üì¶',
      'shipped': 'üöö',
      'delivered': '‚úÖ',
      'cancelled': '‚ùå',
      'confirmed': '‚úÖ',
      'preparing': 'üë®‚Äçüç≥',
      'ready': 'üéØ'
    };
    return statusMap[status] || 'üì¶';
  }

  getStatusText(status) {
    const statusMap = {
      'Processing': 'ƒêang x·ª≠ l√Ω',
      'Shipped': 'ƒêang giao h√†ng',
      'Delivered': 'ƒê√£ giao h√†ng',
      'Cancelled': 'ƒê√£ h·ªßy',
      'pending': 'Ch·ªù x·ª≠ l√Ω',
      'processing': 'ƒêang x·ª≠ l√Ω',
      'shipped': 'ƒêang giao h√†ng',
      'delivered': 'ƒê√£ giao h√†ng',
      'cancelled': 'ƒê√£ h·ªßy',
      'confirmed': 'ƒê√£ x√°c nh·∫≠n',
      'preparing': 'ƒêang chu·∫©n b·ªã',
      'ready': 'S·∫µn s√†ng giao h√†ng'
    };
    return statusMap[status] || status;
  }
}

module.exports = OptimizedAIOrderTool;